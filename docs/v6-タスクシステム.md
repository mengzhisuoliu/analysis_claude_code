# v6: タスクシステム

**コアの洞察: 個人の付箋からチームのカンバンボードへ。**

v2で導入したTodoWriteは「モデルが計画を忘れる」問題を解決した。しかし圧縮（v5）とサブエージェント（v3）が加わると、TodoWriteの限界が露呈する。

## 問題

```
TodoWriteの問題:
  1. 書き込みは上書きモードのみ（毎回完全なリストを送信）
  2. 永続化なし（圧縮後にtodoが消える）
  3. オーナーなし（誰がこのタスクをやっている？）
  4. 依存関係なし（AはBの前に完了しなければならない）
  5. 並行安全でない（2つのエージェントが同時に書く = データ消失）
```

v5の圧縮はメモリ内のtodoを消去する。サブエージェント間でタスクを共有できない。タスクシステムはタスク管理を根本から再設計する。

## TodoWrite vs Tasks

| 特徴 | TodoWrite (v2) | Tasks (v6) |
|------|---------------|------------|
| 操作方式 | 上書き | CRUD（作成/読取/更新/削除） |
| 永続化 | メモリのみ（圧縮後消失） | ディスクファイル（圧縮後も生存） |
| 並行性 | 安全でない | ファイルロック |
| 依存関係 | なし | blocks / blockedBy |
| オーナー | なし | エージェント名 |
| マルチエージェント | 非対応 | ネイティブ対応 |

## データモデル

```python
@dataclass
class Task:
    id: str              # 自動採番ID
    subject: str         # 命令形タイトル: "Fix auth bug"
    description: str     # 詳細な説明
    status: str = "pending"  # pending | in_progress | completed
    active_form: str = ""    # 進行形: "Fixing auth bug"
    owner: str = ""          # 担当エージェント
    blocks: list = []        # このタスクがブロックしているタスク
    blocked_by: list = []    # このタスクをブロックしている前提タスク
```

各フィールドが必要な理由:

| フィールド | 理由 |
|-----------|------|
| `id` | CRUDに一意識別子が必要 |
| `owner` | マルチエージェント時に誰が担当かを識別 |
| `blocks/blockedBy` | タスク編成の依存グラフ |
| `description` | 別のエージェントでもタスクを理解できる |

## 4つのツール

```python
# TaskCreate: タスクを作成
task_create("Fix auth bug", description="...", active_form="Fixing auth bug")
# -> {"id": "1", "subject": "Fix auth bug"}

# TaskGet: 詳細を読取
task_get("1")
# -> {id, subject, description, status, blocks, blockedBy}

# TaskUpdate: ステータス、依存、オーナーを更新
task_update("1", status="in_progress")  # ownerを自動割り当て
task_update("2", addBlockedBy=["1"])    # 2は1に依存

# TaskList: 全タスクを一覧
task_list()
# -> [{id, subject, status, owner, blockedBy}, ...]
```

## 依存グラフ

```
TaskCreate: "Set up database"       -> #1
TaskCreate: "Write API endpoints"   -> #2
TaskCreate: "Write tests"           -> #3

TaskUpdate: id=2, addBlockedBy=["1"]     # APIはデータベースに依存
TaskUpdate: id=3, addBlockedBy=["1","2"] # テストは両方に依存
```

レンダリング結果:

```
#1. [>] Set up database          (in_progress)
#2. [ ] Write API endpoints      blocked by: #1
#3. [ ] Write tests              blocked by: #1, #2
```

#1が完了すると、#2のblockedByが自動でクリアされ、実行可能になる。

## 永続化

```python
def save_task(task):
    """ファイルレベルのロックで並行安全を保証"""
    path = f"tasks/{task.id}.json"
    with FileLock(path + ".lock"):
        with open(path, 'w') as f:
            json.dump(task.to_dict(), f)
```

データベースではなくファイルを使う理由:
- タスクごとに1ファイル = きめ細かなロック
- サブエージェントが別プロセスにいる可能性がある
- JSONファイルは人間が読める、デバッグが容易

## 圧縮との連携 (v5)

タスクはディスクに永続化されるため、圧縮時に失われない:

```
圧縮前:  [100ターンの対話] + [5つのタスクがディスク上]
圧縮後:  [要約 + 最近5ターン] + [5つのタスクがディスク上]  <- タスクは完全に保持
```

TodoWriteにはこれができなかった。TodoWriteのタスクはメッセージ履歴の中にしかなく、圧縮後は消えてしまう。

## Feature Gate

教育コードでは、v6はTodoWriteを完全にTasksシステムに置き換える。2つのシステムは概念的に排他的:

```python
# v2はTodoWriteを使用（メモリ内、上書きのみ）
# v6はTaskCreate/Get/Update/Listを使用（ディスク永続化、CRUD操作）

# 実装では、v6は単にTasksツールを含み、TodoWriteを削除
ALL_TOOLS = BASE_TOOLS + [TASK_CREATE_TOOL, TASK_GET_TOOL,
                          TASK_UPDATE_TOOL, TASK_LIST_TOOL]
```

重要な違い: TodoWriteのデータはメッセージ履歴にのみ存在（圧縮で消失）、Tasksのデータはディスクに存在（圧縮後も保持）。

## より深い洞察

> **個人のメモからチームのカンバンボードへ。**

TodoWriteは付箋のようなもの。一人で使い、使い終わったら捨てる。Tasksはプロジェクトボードのようなもの。複数人で協力し、ステータスが遷移し、依存関係を追跡する。

これは**協調パラダイムの転換**:
- TodoWrite: モデルの自己規律ツール（v2の哲学: 制約が可能にする）
- Tasks: マルチエージェントの調整プロトコル（v6の哲学: 協調が可能にする）

エージェントが単体からグループになるとき、タスク管理は「チェックリスト」から「システム」へ進化しなければならない。

---

**チェックリストで1つのエージェントが整理され、タスクシステムでエージェント群が秩序を持つ。**

[<< v5](./v5-コンテキスト圧縮.md) | [READMEに戻る](../README_ja.md) | [v7 >>](./v7-バックグラウンドタスク.md)
