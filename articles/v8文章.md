# mini Claude Code v8：一群 Agent 无所不能 -- Teammate 机制

v3 引入了子代理。它很有用，但有一个根本局限：**子代理是一次性的**。

```sh
子代理的一生:
  出生 -> 接收指令 -> 执行 -> 返回结果 -> 销毁
  (全程约 30 秒, 像一个匿名函数调用)
```

对于"探索一下代码库结构"这样的任务，一次性子代理完全够用。但当任务变成"前端和后端同时开发一个新功能"，问题就暴露了：

- 前端子代理做完了，它的上下文就没了。后端需要问前端"你的 API 接口定义是什么"，但前端已经"死了"
- 两个子代理之间无法直接通信，必须通过主代理中转
- 没有共享的任务追踪，一个子代理不知道另一个的进度

v8 引入的 Teammate 机制，彻底改变了 Agent 之间的协作方式。这不再是"老板派实习生跑腿"，而是"经理和同事们一起在办公室工作"。

## 1. 三种角色的本质差异

```sh
Subagent (实习生):
  "去把这个文件分析一下, 回来告诉我结果"
  -> 干一件事, 回来汇报, 离开

Teammate (同事):
  "你负责后端开发, 有问题随时沟通"
  -> 持续工作, 自主领活, 互相沟通

Team Lead (经理):
  "我来拆任务, 你们各自负责, 有进展告诉我"
  -> 拆任务, 分配, 审核, 协调
```

对应到技术实现：

| 特性 | Subagent (v3) | Teammate (v8) |
|------|---------------|---------------|
| 生命周期 | 执行一次就销毁 | 持久运行（active <-> idle） |
| 通信方式 | 返回值（单向） | 消息协议（双向, 5 种类型） |
| 并行方式 | 伪并行（主 Agent 等待） | 真并行（独立线程） |
| 任务管理 | 无 | 共享 Tasks 看板 (v6) |
| 自主性 | 无（被动接受指令） | 有（自动领取未分配任务） |

## 2. 系统架构

```sh
+-------------------------------------------------------------------+
|                        Team Lead (主 Agent)                         |
|                                                                     |
|  工具: TeamCreate, SendMessage, TeamDelete, TaskCreate, TaskList    |
+-------------------------------------------------------------------+
      |                    |                    |
   [创建]              [消息]              [消息]
      |                    |                    |
+-------------+   +-------------+   +-------------+
| Teammate:   |   | Teammate:   |   | Teammate:   |
| "frontend"  |   | "backend"   |   | "analyst"   |
|             |   |             |   |             |
| - 独立线程   |   | - 独立线程   |   | - 独立线程   |
| - 独立上下文 |   | - 独立上下文 |   | - 独立上下文 |
| - 独立压缩   |   | - 独立压缩   |   | - 独立压缩   |
+------+------+   +------+------+   +------+------+
       |                 |                 |
       +-----------------+-----------------+
                         |
                  +------+------+
                  |   共享资源    |
                  |             |
                  | .tasks/    | <- 所有人看同一个看板
                  | .teams/    | <- 消息邮箱
                  +-------------+
```

每个 Teammate 是一个独立的 Agent 循环，运行在自己的线程中，有自己的消息历史和上下文窗口。它们通过两个共享机制协作：Tasks 文件（v6）和消息邮箱。

## 3. Teammate 数据模型

```python
@dataclass
class Teammate:
    name: str                 # 唯一名称: "frontend", "backend"
    team_name: str            # 所属团队
    status: str = "active"    # active | idle | shutdown
    thread: threading.Thread  # 执行线程
    inbox_path: Path          # 消息邮箱文件路径
```

Teammate 的状态机非常简单：

```sh
  +--------+      工作完成       +------+
  | active | ----------------> | idle |
  +--------+                   +------+
      ^                           |
      |     收到新消息/发现新任务    |
      +---------------------------+

  任何状态 -- shutdown_request --> [shutdown]
```

## 4. 五种消息类型

```python
class TeammateManager:
    MESSAGE_TYPES = {
        "message",                  # 点对点消息
        "broadcast",                # 广播给所有人
        "shutdown_request",         # 请求关闭
        "shutdown_response",        # 确认关闭
        "plan_approval_response",   # Team Lead 审批计划
    }
```

为什么需要 5 种？因为团队协作中存在不同性质的沟通：

| 消息类型 | 场景 | 方向 |
|---------|------|------|
| `message` | "后端 API 接口文档在 docs/api.md" | 点对点 |
| `broadcast` | "数据库 schema 已变更, 所有人注意" | 一对多 |
| `shutdown_request` | "项目完成了, 请收尾" | Lead -> Teammate |
| `shutdown_response` | "我这边已经收尾完毕" | Teammate -> Lead |
| `plan_approval_response` | "你的重构方案批准了, 执行吧" | Lead -> Teammate |

消息通过文件邮箱传递（`.teams/<team>/<name>_inbox.jsonl`），用文件而不是内存队列，原因和 Tasks 一样：跨线程安全，人类可调试。

## 5. Teammate 工作循环：不死的 Agent

这是 v8 最核心的代码。子代理执行完就销毁，Teammate 则进入"工作-空闲-工作"的持续循环：

```python
def _teammate_loop(self, teammate, initial_prompt):
    sub_system = f"You are teammate '{teammate.name}' in team '{teammate.team_name}'..."
    sub_messages = [{"role": "user", "content": initial_prompt}]

    while teammate.status != "shutdown":
        # === Active 阶段: 正常 Agent Loop ===
        teammate.status = "active"
        response = client.messages.create(
            model=MODEL, system=sub_system,
            messages=sub_messages, tools=TEAMMATE_TOOLS, max_tokens=8000,
        )
        if response.stop_reason == "tool_use":
            # 有工具调用, 执行后继续
            results = [execute_and_collect(tc) for tc in tool_calls]
            sub_messages.append({"role": "assistant", "content": response.content})
            sub_messages.append({"role": "user", "content": results})
            continue

        # === Idle 阶段: 等待新消息或新任务 ===
        teammate.status = "idle"
        for _ in range(30):  # 每 2 秒检查一次, 共 60 秒
            if teammate.status == "shutdown":
                return

            new_messages = self.check_inbox(teammate.name, teammate.team_name)
            if new_messages:
                if any(m.get("type") == "shutdown_request" for m in new_messages):
                    return
                sub_messages.append({"role": "user", "content": format_messages(new_messages)})
                break

            # 自动领取未认领的任务
            unclaimed = [t for t in TASK_MGR.list_all()
                         if t.status == "pending" and not t.owner and not t.blocked_by]
            if unclaimed:
                TASK_MGR.update(unclaimed[0].id, status="in_progress", owner=teammate.name)
                sub_messages.append({"role": "user", "content": f"Task #{unclaimed[0].id}: ..."})
                break

            time.sleep(2)
```

关键行为：

1. **Active 阶段**：正常的 Agent Loop，调用工具、思考、执行
2. **工作完成后不销毁**：进入 Idle 阶段
3. **Idle 阶段做两件事**：检查邮箱是否有新消息；检查看板是否有未认领任务
4. **自动领活**：如果看板上有 pending 且无 owner 且无阻塞的任务，自动认领并开始执行
5. **收到 shutdown_request 才真正退出**

## 6. 团队创建与 Teammate 生成

Team Lead 通过三个工具管理团队：

```python
# 1. 创建团队
TeamCreate(name="rest-to-graphql")
# -> "Team 'rest-to-graphql' created"

# 2. 生成 Teammate (通过 Task 工具, 指定 team_name + name)
Task(
    description="Handle backend migration",
    prompt="You are responsible for backend development. "
           "Analyze REST endpoints and implement GraphQL resolvers.",
    agent_type="code",
    team_name="rest-to-graphql",
    name="backend"
)
# -> {"name": "backend", "team": "rest-to-graphql", "status": "active"}

# 3. 与 Teammate 通信
SendMessage(recipient="backend", content="Database schema is ready, you can start.")

# 4. 解散团队
TeamDelete(name="rest-to-graphql")
# -> "Team deleted, 3 teammates notified"
```

注意 Teammate 是通过已有的 `Task` 工具生成的，只需额外传入 `team_name` 和 `name` 参数。这个设计复用了现有接口：

```python
def run_subagent(description, prompt, agent_type, background=False, team_name=None, name=None):
    if team_name and name:
        # 有 team_name + name -> 生成持久 Teammate
        return TEAM_MGR.spawn_teammate(name, team_name, prompt)

    if background:
        # 有 run_in_background -> 后台子代理 (v7)
        return BG.run_in_background(lambda: _exec_subagent(...), "agent")

    # 默认: 同步子代理 (v3)
    return _exec_subagent(description, prompt, agent_type)
```

同一个工具，三种模式：同步子代理、后台子代理、持久 Teammate。

## 7. 三个机制的联动

v8 不是孤立的特性，而是 v5-v7 所有机制的汇聚点：

```sh
完整协作流程: "把应用从 REST 迁移到 GraphQL"

Team Lead:
  1. TeamCreate("rest-to-graphql")

  2. TaskCreate("Analyze REST endpoints")              -> #1
     TaskCreate("Design GraphQL schema")               -> #2, blockedBy=#1
     TaskCreate("Implement resolvers")                  -> #3, blockedBy=#2
     TaskCreate("Update frontend queries")              -> #4, blockedBy=#3

  3. Task(name="analyst",  team_name=..., prompt="分析 REST 端点")
     Task(name="backend",  team_name=..., prompt="处理后端迁移")
     Task(name="frontend", team_name=..., prompt="处理前端更新")

执行过程:

  analyst:  看到 #1 -> 认领 -> 执行 -> 完成
                                         |
  backend:  空闲... <--- #2 解锁 --------+
            认领 #2 -> 完成 -> 认领 #3 -> 完成
                                           |
  frontend: 空闲... <--- #4 解锁 ----------+
            认领 #4 -> 执行 -> 完成

  Team Lead: 收到通知 -> 所有任务完成
             SendMessage("all", type="broadcast", content="收尾检查")
             TeamDelete("rest-to-graphql")
```

三个机制各司其职：

| 机制 | 角色 | 比喻 |
|------|------|------|
| Tasks (v6) | 共享看板 | 办公室白板，所有人看同一个 |
| Background (v7) | 并行执行 | 每人一张桌子，同时干活 |
| Messages (v8) | 点对点通信 | 同事之间直接对话 |

缺少任何一个，协作都不完整：
- 没有 Tasks：不知道做什么、谁在做
- 没有 Background：不能并行，回到串行等待
- 没有 Messages：只能通过 Lead 中转，效率低下

## 8. 更深的洞察：Agent 系统的终极形态

v0 到 v8 的演进，讲了一个完整的故事：

```sh
v0: 一个 Agent, 一个工具
v1: 一个 Agent, 多个工具
v2: 一个 Agent, 有计划
v3: 一个 Agent, 能派人
v4: 一个 Agent, 有知识
v5: 一个 Agent, 能遗忘
v6: 多个 Agent, 有看板
v7: 多个 Agent, 能并行
v8: 多个 Agent, 能协作
```

每一步都在解决前一步暴露的瓶颈。v8 的 Teammate 是这条线的终点——不是因为不能再加功能，而是因为 Agent 协作的基本元素已经齐全了：**共享状态（Tasks）+ 并行执行（Background）+ 双向通信（Messages）**。

更深层的洞察是：**Agent 系统的终极形态不是一个更聪明的模型，而是一群能协作的模型。**

v8 的 Teammate 不比 v3 的 Subagent 更"聪明"（用的是同一个模型），但它们的**协作方式**更成熟：持久存在、自主领活、双向沟通、共享状态。人类文明的复杂性也不是来自单个大脑的进化，而是来自协作机制的进化：语言、文字、组织、制度。

## 9. 完整回顾

| 版本 | 核心主题 | 行数 | 关键洞察 |
|------|----------|------|----------|
| v0 | Bash is All | ~50 行 | 一个工具 + 递归 = 完整 Agent |
| v1 | Model as Agent | ~200 行 | 模型是 80%，代码是工具循环 |
| v2 | 结构化规划 | ~300 行 | Todo 让计划可见 |
| v3 | 分而治之 | ~450 行 | 子代理隔离上下文 |
| v4 | 领域专家 | ~550 行 | Skills 注入知识 |
| v5 | 永不遗忘 | ~650 行 | 三层压缩模拟记忆 |
| v6 | 团队看板 | ~750 行 | Tasks 替代 Todo |
| v7 | 并行执行 | ~850 行 | 后台任务 + 通知 Bus |
| **v8** | **团队协作** | **~1000 行** | **Teammate 持久协作** |

九个版本，约 1000 行 Python，覆盖了 Claude Code 从单 Agent 到多 Agent 协作的完整设计。不是"简化版"，而是每个核心概念的精确还原。

---

**一个 Agent 能力有限，一群 Agent 无所不能。Agent 系统的进化不是让个体更强，而是让群体更协调。**

完整代码见仓库 `v8_teammate_agent.py`。
